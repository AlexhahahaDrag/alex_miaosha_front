---
description: 
globs: 
alwaysApply: true
---
# Alex Miaosha Front - Cursor 规则配置

## 项目概述
这是一个基于 Vue 3 + TypeScript + Ant Design Vue 的前端项目。

## 核心技术栈
- **框架**: Vue 3 + TypeScript + Vite
- **UI库**: Ant Design Vue 4.x
- **状态管理**: Pinia + pinia-plugin-persistedstate
- **路由**: Vue Router 4 (动态路由)
- **HTTP**: Axios (统一请求拦截)
- **图表**: ECharts
- **样式**: Less/SCSS + CSS预处理器
- **图标**: unplugin-icons (自动导入)
- **组件**: unplugin-vue-components (自动导入)
- **工具**: crypto-js, moment, mathjs, bignumber.js

## 代码风格和规范

### 1. TypeScript 规范
- 严格遵循 TypeScript 类型检查
- 使用 interface 定义数据结构
- API 响应使用统一的 `ResponseBody<T>` 类型
- 优先使用 `ref` 和 `reactive` 的类型推导
- 组件 props 必须定义明确类型

### 2. Vue 3 组合式 API 风格
- **必须使用** Vue 3 Composition API，不使用 Options API
- 使用 `<script setup>` 语法糖
- 响应式数据优先使用 `ref()` 而非 `reactive()`
- 生命周期钩子使用 `onMounted`, `onUnmounted` 等
- 使用 `defineEmits` 和 `defineProps` 定义组件接口

### 3. 组件结构规范
```vue
<template>
  <!-- 模板内容 -->
</template>

<script setup lang="ts">
// 1. 导入依赖
// 2. defineProps / defineEmits
// 3. 响应式数据
// 4. 计算属性
// 5. 方法定义
// 6. 生命周期钩子
</script>

<style lang="less" scoped>
/* 组件样式 */
</style>
```

### 4. API 调用规范
- 所有 API 调用使用项目的 `request` 工具 (`@/utils/request/request.ts`)
- API 函数放在 `src/api` 目录下，按业务模块分类
- 使用统一的类型定义 `ResponseBody<T>`, `PageResult<T>`, `RequestResult<T>`
- 错误处理使用 `message.error()` 显示

### 5. 路径别名使用
- `@/` → `src/`
- `@v/` → `src/views/`
- `@u/` → `src/utils/`
- `@a/` → `src/api/`
- `@r/` → `src/router/`

### 6. 状态管理 (Pinia)
- 使用 `defineStore` 创建 store
- Store 文件命名: `[moduleName].ts`
- 支持持久化存储 (pinia-plugin-persistedstate)
- State 必须定义明确的 TypeScript 类型

### 7. 路由和权限
- 使用动态路由 + 权限控制
- 路由配置使用 `MenuDataItem` 类型
- 组件路径使用 `import.meta.glob` 动态导入
- 权限判断基于角色 (roleCode) 和权限列表 (permissionList)

### 8. 样式规范
- 使用 Less 预处理器
- 组件样式使用 `scoped`
- 响应式布局使用 Ant Design 的栅格系统
- 颜色变量和主题配置统一管理

### 9. 组件自动导入
- Vue 组件自动导入 (unplugin-vue-components)
- Ant Design Vue 组件按需导入
- 图标自动导入 (unplugin-icons)
- Vue/Vue Router API 自动导入 (unplugin-auto-import)

## 开发约定

### 1. 文件命名
- 组件文件: PascalCase (如 `UserManager.vue`)
- 工具文件: camelCase (如 `request.ts`)
- 类型文件: camelCase + 'Ts' 后缀 (如 `userManagerTs.ts`)
- 页面目录: kebab-case

### 2. 变量命名
- 响应式数据: camelCase
- 常量: UPPER_SNAKE_CASE
- 组件名: PascalCase
- 方法名: camelCase

### 3. 错误处理
- 使用 try-catch 包装异步操作
- 统一使用 `message.error()` 显示错误信息
- API 错误通过请求拦截器统一处理

### 4. 性能优化
- 使用 `v-memo` 优化列表渲染
- 大组件使用 `defineAsyncComponent` 异步加载
- 图片使用懒加载
- 合理使用 `computed` 缓存计算结果

### 5. 安全规范
- 所有用户输入进行验证
- 敏感数据使用加密传输 (crypto-js)
- Token 存储在 localStorage 并设置过期机制
- 路由守卫进行权限验证

## 代码示例

### API 调用示例
```typescript
import request from '@/utils/request/request';
import type { ResponseBody, PageResult } from '@/api/typing';

export interface UserInfo {
  id: string;
  name: string;
}

export const getUserList = (params: any): Promise<ResponseBody<PageResult<UserInfo>>> => {
  return request.post('/user/list', params);
};
```

### 组件示例
```vue
<template>
  <a-card title="用户列表">
    <a-table 
      :dataSource="userList" 
      :columns="columns"
      :loading="loading"
    />
  </a-card>
</template>

<script setup lang="ts">
interface UserInfo {
  id: string;
  name: string;
}

const userList = ref<UserInfo[]>([]);
const loading = ref(false);

const columns = [
  { title: '姓名', dataIndex: 'name', key: 'name' }
];

const fetchUserList = async () => {
  loading.value = true;
  try {
    const res = await getUserList({});
    if (res.code === 200) {
      userList.value = res.data.data;
    }
  } catch (error) {
    message.error('获取用户列表失败');
  } finally {
    loading.value = false;
  }
};

onMounted(() => {
  fetchUserList();
});
</script>
```

### Store 示例
```typescript
export const useUserStore = defineStore('user', {
  state: (): UserState => ({
    userInfo: null,
    token: '',
  }),
  
  getters: {
    getUserInfo(): UserInfo | null {
      return this.userInfo;
    }
  },
  
  actions: {
    setUserInfo(userInfo: UserInfo) {
      this.userInfo = userInfo;
    }
  },
  
  persist: piniaPersistConfig('user')
});
```

## 开发工具配置
- ESLint + Prettier 代码格式化
- Husky + lint-staged Git 提交钩子
- TypeScript 严格模式
- Vite 构建优化配置

## 注意事项
1. 严格遵循 TypeScript 类型检查
2. 组件必须使用 Composition API
3. 所有 API 调用必须进行错误处理
4. 新增页面需要添加相应的路由和权限配置
5. 样式使用 Less 预处理器并保持 scoped

6. 遵循项目现有的文件结构和命名规范 